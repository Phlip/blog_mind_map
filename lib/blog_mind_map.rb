
class BlogMindMap
  def initialize(post = nil)
    @current_post = post
  end

  def affinity(from, to)
    (from.tags & to.tags).length
  end  #  the & is Ruby's set intersection operator

  def affinity_edge(from, to)
    return [ from == @current_post || to == @current_post ? 0 : 1,
            -affinity(from, to),
              from, to ]
  end

  def affinity_edges
    posts = Post.order(:title).all    #  TODO  abstract the Post type and its search method
      #  like ActiveRecord <code>Post.find(:all, :order => 'title')</code>
      
    returning [] do |edges|
      posts.each_with_index do |from, index|
        posts[index + 1 .. -1].each do |to|
          a = affinity_edge(from, to)
          edges << a if a[1] != 0
        end
      end
    end
  end

  def <=> other
    self.title <=> other.title
  end  #  a tie breaker...

  def sorted_affinity_edges
    edges = affinity_edges.sort
    edges[1..-1].each{|edge| edge[0] = 1 }
    return edges.sort
  end  #  that wasn't too heinous, now was it?

  def cull
    table = sorted_affinity_edges
    posts = {}

    returning [] do |edges|
      table.map do |prime, weight, from, to|
        if prime == 0 or posts[from.title] != posts[to.title]
          posts[from.title] = true
          posts[  to.title] = true
          edges << [from, to]
        end
      end  #  Prim's minimum spanning tree algorithm
    end
  end


  def style_node(post)
    return { :fontsize => post == @current_post ? '12' : '9',
          :peripheries => post == @current_post ?  '2' : '0',
                :color => :white, 
                :label => post.title,
                :shape => :box,
                :style => :filled,
                :width => '0',
                :height => '0',
                }
  end  #  BDD-ing this method directly would be easy...

  def to_dot
    require 'graphviz_r'
    gvr = GraphvizR.new('mind_map')
    gvr.graph[:bgcolor => 'transparent']
    edges = cull()

    edges.flatten.uniq.each do |post|
      def post.dot_id; "post_#{ id }"; end
      gvr[post.dot_id][ style_node(post) ]
    end

    edges.each{ |from, to|  gvr[from.dot_id] - gvr[to.dot_id]  }
    return gvr.to_dot                #  that ^ declares a GraphViz edge!
  end

  def to_image(format)
    image = "images/post_#{@current_post.id}.#{format}"
    path = Pathname.new(Merb.root) + "public" + image
    command = "dot -T#{format} -o #{path.to_s.inspect}"
    IO.popen(command, 'w'){|f| f.write(to_dot) }
    return image
  end

=begin

That specification inspires us to add our mind map to the 
upper left corner of a post.

Forcing that PNG file to be a real mind map generated by 
MindMap is left as an exercize for the reader!

Here's the new action code in the controller:
=end

# class ::Posts < Application
# 
#   # GET /posts/:id
#   def show
#         provides :rss
#     @post = Post[params[:id]]
#     @image = MindMap.new(@post).to_image(:png)
#     raise NotFound unless @post
#     display @post
#   end
#   
# end

=begin

And here's the new View code (in glorious HAML):

 .post
   %div{ :style => 'clear:right; float:right;' }
     %img{ :src => '/' + @image }
   %h2= @post.title

It looks more familiar as its HTML output:

        <div class='post'>
          <div style='clear:right; float:right;'><img src='/images/post_3408.png' /></div>

          <h2>Jammin'</h2>

          <p class='auth'>Posted by Bob Marley <span class='typo_date'>on Fri Feb 13 20:21:27 -0800 2009</span></p>

<h2>Do List</h2>

* no kewt helper class is complete without a plugin and 
   an <code>acts_as_mind_map</code> directive...
* MindMap#to_mind is overdue for an Object Method refactor
* Stash the maps, and don't recook them each time, and time stamp them
* real helper tag on the image

      # TODO fix deny before publishing
#  TODO  upgrade xpath so ?* does contains().
#  TODO  ?. => // does a regexp

=end

end

# def returning(arg)
#   yield(arg)
#   return arg
# end

